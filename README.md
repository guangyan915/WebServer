# WebServer

## 项目初衷

自己完成过一个微型WebServer，还有一个网盘的项目。在这过程中学习到了不少东西，接下来结合整理所学到的新知识重新构建一个性能好点的WebServer。

看过小林coding里一篇文章：[ 高性能网络模式：Reactor 和 Proactor]([9.3 高性能网络模式：Reactor 和 Proactor | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/os/8_network_system/reactor.html#演进))

- 如果没有事件发生，线程只需阻塞在这个系统调用，而无需像前面的线程池方案那样轮训调用 read 操作来判断是否有数据。
- 如果有事件发生，内核会返回产生了事件的连接，线程就会从阻塞状态返回，然后在用户态中再处理这些连接对应的业务即可。

当下开源软件能做到网络高性能的原因就是 I/O 多路复用吗？

是的，基本是基于 I/O 多路复用，用过 I/O 多路复用接口写网络程序的同学，肯定知道是面向过程的方式写代码的，这样的开发的效率不高。

于是，大佬们基于面向对象的思想，对 I/O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。

大佬们还为这种模式取了个让人第一时间难以理解的名字：**Reactor 模式**。

Reactor 翻译过来的意思是「反应堆」，可能大家会联想到物理学里的核反应堆，实际上并不是的这个意思。

这里的反应指的是「**对事件反应**」，也就是**来了一个事件，Reactor 就有相对应的反应/响应**。

事实上，Reactor 模式也叫 `Dispatcher` 模式，我觉得这个名字更贴合该模式的含义，即 **I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程**。

Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：

- Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；
- 处理资源池负责处理事件，如 read -> 业务逻辑 -> send；

Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：

- Reactor 的数量可以只有一个，也可以有多个；
- 处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程；

## 模块设计

### 单Rector多线程模式

![单Reactor多线程](https://github.com/guangyan915/WebServer/assets/127613883/2e716aaa-57c3-4930-8f5b-84694bc6e260)


- 采用IO多路复用：Epoll ET模式
- 新加入事件为可读事件，当事件处理完将事件标记为可写事件，可写事件处理完判断连接是否为长连接，是否超时从而关闭连接或者将事件标记为可读事件。（这样做保证缓冲区满了，服务器还能处理其他业务）

### 池化模块

- 线程池：使用可变模板参数、生产者消费者模型实现一个添加任意任务的线程池
- 对象内存池：为对象分配内存（模板实现），优先从自由链表里取内存，自由链表没有内存时，会向已申请到的内存块里取内存（没有的话会向操作系统申请），释放的内存头插到自由链表上。
- mysql连接池：服务器启动后就创建了一些连接示例，放到mysql连接池里，用的时候取，用完换回来。

### 缓冲区模块

- 建立一个可以动态扩容且通用的的缓冲区模块，为日志、以及socket的读写创建缓冲区。

### 日志模块

- 方便进行调试以及定位问题。日志等级：DEBUG、INFO、WARN、ERROR
- 全局使用一个日志系统，使用缓冲区来存储日志数据，一个异步线程会将缓冲区数据刷到日志文件里。

### 配置文件模块

- 方便对webServ的配置：文件描述符数量、超时时间、线程池线程数量、是否采用ET模式、对象池、数据库连接池、资源路径、log相关配置等等。。。

### HTTP模块

- 每个连接维护自己的读和写缓冲区，使用mmap和writev加快文件写入socket缓冲区

- 从缓冲区读取数据，通过状态机解析报文
- 构建相应的相应相应写入缓冲区
- 支持get请求和post请求提交数据（使用axios完成数据提交，server完成响应实现登录和注册）
